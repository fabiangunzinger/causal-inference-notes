<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>notes_on_holland1986statistics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="notes_on_holland1986statistics_files/libs/clipboard/clipboard.min.js"></script>
<script src="notes_on_holland1986statistics_files/libs/quarto-html/quarto.js"></script>
<script src="notes_on_holland1986statistics_files/libs/quarto-html/popper.min.js"></script>
<script src="notes_on_holland1986statistics_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="notes_on_holland1986statistics_files/libs/quarto-html/anchor.min.js"></script>
<link href="notes_on_holland1986statistics_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="notes_on_holland1986statistics_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="notes_on_holland1986statistics_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="notes_on_holland1986statistics_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="notes_on_holland1986statistics_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<section id="notes-on-holland1986statistics" class="level1">
<h1>Notes on holland1986statistics</h1>
<ul>
<li>This paper coins the “Rubin Model” – not the model itself, the name for it.</li>
</ul>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<ul>
<li><p>Wants to make the point that statistics has a lot to say about causal inference and thus needn’t limit itself to associational inference.</p></li>
<li><p>Also wants to show fundamental differences between causal and associational inference.</p></li>
<li><p>Overall layout:</p>
<ul>
<li><p>Introduce associational and causal inference approaches and compare the two.</p></li>
<li><p>Apply them to various ideas and philosophies about causal inference</p></li>
</ul></li>
</ul>
</section>
<section id="model-for-associational-inference" class="level2">
<h2 class="anchored" data-anchor-id="model-for-associational-inference">Model for associational inference</h2>
<ul>
<li><p>A population <span class="math inline">\(U\)</span> of units with individual unit <span class="math inline">\(i\)</span></p></li>
<li><p>A variable is a real-valued function defined on every <span class="math inline">\(i\)</span></p></li>
<li><p>The value of a variable for <span class="math inline">\(i\)</span> is the number assigned by some measurement process to <span class="math inline">\(i\)</span></p></li>
<li><p><span class="math inline">\(Y\)</span> is the response variable of interest, and there is a value <span class="math inline">\(Y_i\)</span> associated with each <span class="math inline">\(i\)</span></p></li>
<li><p>Define <span class="math inline">\(X\)</span> as another variable defined on <span class="math inline">\(U\)</span>, and call <span class="math inline">\(X\)</span> an attribute of the units, with a value <span class="math inline">\(X_i\)</span> associated with each <span class="math inline">\(i\)</span></p></li>
<li><p>Logically, however, <span class="math inline">\(Y\)</span> and <span class="math inline">\(X\)</span> are on equal footing: they are both variables defined on <span class="math inline">\(U\)</span></p></li>
<li><p>For associational inference, we are satisfied to understand <em>how</em> <span class="math inline">\(Y\)</span> varies with <span class="math inline">\(X\)</span></p></li>
<li><p>A probability is a proportion of units in <span class="math inline">\(U\)</span></p></li>
<li><p>The expected value the average over <span class="math inline">\(U\)</span></p></li>
<li><p>Conditional expected values the average over a subset of <span class="math inline">\(U\)</span> where subsets are defined on the value of a variable</p></li>
<li><p>It’s in the above senses that the model described in the paper is a population model</p></li>
<li><p>The role of time, in associational inference, is merely to define the population of units and to specify the operational meaning of the particular variables (for causal inference, time will be more important)</p></li>
<li><p>The <em>joint distribution</em> of <span class="math inline">\(Y\)</span> and <span class="math inline">\(A\)</span> over <span class="math inline">\(U\)</span> is specified by <span class="math inline">\(P(Y = y, X = x)\)</span>, which is the proportion of units in <span class="math inline">\(U\)</span> for which <span class="math inline">\(Y_i = y\)</span> and <span class="math inline">\(X_i = x\)</span>.</p></li>
<li><p>The <em>associational parameters</em> are described by this joint distribution. As an example, the conditional distribution of <span class="math inline">\(Y\)</span> given <span class="math inline">\(A\)</span> is specified as <span class="math inline">\(P(Y = y | X = x)\)</span>, which equals <span class="math inline">\(P(Y = y, X = x) / P(X = x)\)</span>. This conditional distribution describes how the distribution of <span class="math inline">\(Y\)</span> over <span class="math inline">\(U\)</span> changes as <span class="math inline">\(X\)</span> varies.</p></li>
<li><p>Another typical associational value is the regression of <span class="math inline">\(Y\)</span> on <span class="math inline">\(X\)</span>, which calculates the conditional expectation <span class="math inline">\(\mathbb{E}[Y | X = x]\)</span>.</p></li>
<li><p>“Associational inference consists of making statistical inferences (estimates, tests, posterior distributions) about associational parameters relating <span class="math inline">\(Y\)</span> and <span class="math inline">\(X\)</span> on the basis of data gathers about <span class="math inline">\(Y\)</span> and <span class="math inline">\(X\)</span> from units in <span class="math inline">\(U\)</span>. In this sense, associational statistics is simply descriptive statistics.”</p></li>
</ul>
</section>
<section id="rubins-model-for-causal-inference" class="level2">
<h2 class="anchored" data-anchor-id="rubins-model-for-causal-inference">Rubin’s Model for causal inference</h2>
<ul>
<li><p>Treatment and cause are used interchangeably.</p></li>
<li><p>The effect of a cause is always relative to another cause (e.g.&nbsp;“A causes B” means A causes B relative to another cause that includes “not A” – if the coffee cup fell over because I moved my hand then that is relative to a state of the world where I didn’t move my hand).</p></li>
<li><p>The key notion of causal inference in this framework is the potential for exposing each unit to cause or treatment (regardless of whether it’s possible in practice) –– each unit needs to be potentially exposable to any of the causes.</p></li>
<li><p>Let <span class="math inline">\(W_i\)</span> be the treatment indicator, with <span class="math inline">\(W_i = 1\)</span> indicating that <span class="math inline">\(i\)</span> is exposed to treatment and <span class="math inline">\(W_i = 0\)</span> that <span class="math inline">\(i\)</span> is exposed to control. The key to our notion of causal inference is that <span class="math inline">\(W_i\)</span> could have been different.</p></li>
<li><p><span class="math inline">\(W_i\)</span> is analogous to <span class="math inline">\(X_i\)</span> above, but with the difference that <span class="math inline">\(W_i\)</span> indicates what cause <span class="math inline">\(i\)</span> is exposed to, which could have been different, while <span class="math inline">\(X_i\)</span> represents a characteristic of <span class="math inline">\(i\)</span>, which could not have been different.</p></li>
<li><p>For each unit, we observe <span class="math inline">\(Y_i^{obs}\)</span> and <span class="math inline">\(W_i\)</span>.</p></li>
<li><p>Time becomes relevant because exposure to a cause must occur at a particular time or during a particular time period. Variables thus divide into two groups: pre-exposure and post-exposure.</p></li>
<li><p>We have potential outcomes <span class="math inline">\(Y_i(1)\)</span> and <span class="math inline">\(Y_i(0)\)</span>.</p></li>
<li><p>The individual-level causal effect is a comparison of the two, usually <span class="math inline">\(Y_i(1) - Y_i(0)\)</span>.</p></li>
<li><p>The Fundamental Problem of Causal Inference is that for any individual we can ever only observe one of the two potential outcomes. This means that we cannot observe the individual-level causal effect.</p></li>
<li><p>There are two general solutions to the fundamental problem:</p>
<ul>
<li><p>The scientific solution uses homogeneity or invariance assumptions, which allows us to measure treatment and control values at different points in time and assume that the only difference in measurement is due to treatment (e.g.&nbsp;time has no effect on measurements – this is what we informally use in everyday life).</p></li>
<li><p>The statistical solution is to rely on information from the entire experiment population and focus on the average treatment effect <span class="math inline">\(\tau = \mathbb{E}[Y(1) - Y(0)] = \mathbb{E}[Y(1)] - \mathbb{E}[Y(0)]\)</span>. The last two terms can be estimated from an experiment where some units are exposed to treatment and others to control. The key insight here is that the statistical approach makes it possible to replace the <em>impossible to observe</em> individual-level causal effect with the <em>possible to estimate</em> average causal effect over a population of units.</p></li>
</ul></li>
<li><p>The truth of either solution depends on the truth of a set of untestable assumptions.</p></li>
</ul>
</section>
<section id="special-cases-of-causal-inference" class="level2">
<h2 class="anchored" data-anchor-id="special-cases-of-causal-inference">Special cases of causal inference</h2>
<ul>
<li>This section shows how simple assumptions allow for causal inference either using the scientific of statistical solution to the Fundamental Problem.</li>
</ul>
<section id="temporal-stability-and-causal-transience" class="level3">
<h3 class="anchored" data-anchor-id="temporal-stability-and-causal-transience">Temporal stability and causal transience</h3>
<ul>
<li><p>If <span class="math inline">\(Y_i(0)\)</span> is stable regardless when it is measured (temporal stability) and <span class="math inline">\(Y_i(1)\)</span> is unaffected by prior exposure to and measurement of effect of control (causal transience), then we can measure individual-level causal effects using the scientific solution by exposing units first to control and then the treatment.</p></li>
<li><p>These two assumptions are often used in Physics, as well as in everyday life (causal effect of my turning on the light switch).</p></li>
</ul>
</section>
<section id="unit-homogeneity" class="level3">
<h3 class="anchored" data-anchor-id="unit-homogeneity">Unit Homogeneity</h3>
<ul>
<li><p>If potential outcomes are identical for different units, then we can apply the scientific solution by calculating <span class="math inline">\(Y_i(1) - Y_j(0)\)</span>.</p></li>
<li><p>This approach, too, is often used in everyday life.</p></li>
</ul>
</section>
<section id="independence" class="level3">
<h3 class="anchored" data-anchor-id="independence">Independence</h3>
<ul>
<li>The statistical solution to the Fundamental Problem relies on estimating</li>
</ul>
<p><span class="math display">\[
\begin{align}
\tau
&amp;= \mathbb{E}[Y(1) - Y(0)] \\
&amp;= \mathbb{E}[Y(1)] - \mathbb{E}[Y(0)].
\end{align}
\]</span></p>
<ul>
<li>We do this by assigning a “large” number of units to treatment and control each, which allows us to observe</li>
</ul>
<p><span class="math display">\[
\begin{align}
\hat{\tau}
&amp;= \mathbb{E}[Y^{obs} | W = 1] - \mathbb{E}[Y^{obs} | W = 0] \\
&amp;= \mathbb{E}[Y(1) | W = 1] - \mathbb{E}[Y(0) | W = 0].
\end{align}
\]</span></p>
<ul>
<li><p>In general, <span class="math inline">\(\hat{\tau}\)</span> needn’t equal <span class="math inline">\(\tau\)</span>: it’s possible that the average potential outcomes conditional on treatment assignment are different from unconditional averages. In particular, this can be the case if <span class="math inline">\(W\)</span> is statistically dependent on potential outcomes (the classic example being self-selection).</p></li>
<li><p>The <em>independence</em> assumption, if plausible, eliminates this statistical dependence. Independence can be achieved by assigning treatments randomly using a credible randomisation mechanism. If the treatment a unit is exposed to is completely random, then it will also be independent of potential outcomes. We then have:</p></li>
</ul>
<p><span class="math display">\[
\begin{align}
\hat{\tau}
&amp;=\mathbb{E}[Y^{obs} | W = 1] - \mathbb{E}[Y^{obs} | W = 0] \\
&amp;= \mathbb{E}[Y(1) | W = 1] - \mathbb{E}[Y(0) | W = 0] \\
&amp;= \mathbb{E}[Y(1)] - \mathbb{E}[Y(0)] \\
&amp;= \mathbb{E}[Y(1) - Y(0)] \\
&amp;= \tau.
\end{align}
\]</span></p>
</section>
<section id="constant-effect" class="level3">
<h3 class="anchored" data-anchor-id="constant-effect">Constant effect</h3>
<ul>
<li><p><span class="math inline">\(\tau\)</span> is the average treatment effect and thus may or may not be relevant for individual <span class="math inline">\(i\)</span>.</p></li>
<li><p>Under the <em>constant effect assumption</em>, we have <span class="math inline">\(Y_i(1) - Y_i(0) = \tau\)</span> for all units <em>i</em>. In this case, <span class="math inline">\(\tau\)</span> is also the individual-level treatment effect.</p></li>
<li><p>The assumption is also called <em>additivity</em> in statistics because it adds a constant amount <span class="math inline">\(\tau\)</span> to the control reponse for each unit.</p></li>
<li><p>The assumption can be partially checked by dividing the population into different subpopulations, and checking whether the estimated ATEs are the same in all subpopulations; if they are, then the assumption is plausible, otherwise it isn’t.</p></li>
<li><p>The constant effect assumption is implied by the unit homogeneity assumption, and is thus a weaker version of it.</p></li>
</ul>
</section>
</section>
<section id="comments-on-selected-philosophies" class="level2">
<h2 class="anchored" data-anchor-id="comments-on-selected-philosophies">Comments on selected philosophies</h2>
</section>
<section id="comments-from-a-few-statisticians" class="level2">
<h2 class="anchored" data-anchor-id="comments-from-a-few-statisticians">Comments from a few statisticians</h2>
</section>
<section id="what-can-be-a-cause" class="level2">
<h2 class="anchored" data-anchor-id="what-can-be-a-cause">What can be a cause?</h2>
</section>
<section id="comments-on-the-causal-inferences-in-various-disciplines" class="level2">
<h2 class="anchored" data-anchor-id="comments-on-the-causal-inferences-in-various-disciplines">Comments on the causal inferences in various disciplines</h2>
</section>
<section id="notation" class="level2">
<h2 class="anchored" data-anchor-id="notation">Notation</h2>
<ul>
<li>I use modern causal inference notation instead of Holland’s original notation, which requires the following changes:</li>
</ul>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Holland notation</th>
<th>Modern notation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(Y_S\)</span></td>
<td><span class="math inline">\(Y^{obs}\)</span></td>
</tr>
</tbody>
</table>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>