<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.353">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>threats_to_validity</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="threats_to_validity_files/libs/clipboard/clipboard.min.js"></script>
<script src="threats_to_validity_files/libs/quarto-html/quarto.js"></script>
<script src="threats_to_validity_files/libs/quarto-html/popper.min.js"></script>
<script src="threats_to_validity_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="threats_to_validity_files/libs/quarto-html/anchor.min.js"></script>
<link href="threats_to_validity_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="threats_to_validity_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="threats_to_validity_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="threats_to_validity_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="threats_to_validity_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="threats-to-validity" class="level1">
<h1>Threats to validity</h1>
<ul>
<li><p>For experiment results to be trustworthy, they need to be reliable, have high internal validity, and high external validity across time.</p></li>
<li><p>Reliability is about reproducibility of our results and the extent to which a rerun of the exact same experiment would lead to the same result. It’s about the stability of measurements and the replicability of the work.</p></li>
<li><p>Internal validity is about the extent to which the treatment effect estimate of our experiment reflects the cause and effect relationship of interest instead of being influenced by other factors. This is all about the design of the experiment.</p></li>
<li><p>External validity is about the extent to which our experiment results generalise both across different populations and across time. Results don’t usually generalise across populations (a feature may work well in one country but not in another), which isn’t a problem because we can (and usually should!) just run the experiment separately for different markets. Traditional experiments do, howerver, assume that experiments generalise over time, in that we think that the effect we estimate during the experiment period will be persistent – i.e.&nbsp;we think that the long-term effect of a change will be the same as the short-term effect.</p></li>
<li><p>In my mind, some of the threats listed below, such as learning effects, could be listed as threats to either internal or external validity. I list them where I think they make most sense given the definitions, but one could argue about that and some authors make different choices – what matters is that you think about them when designing an experiment!</p></li>
</ul>
<section id="threats-to-reliability" class="level2">
<h2 class="anchored" data-anchor-id="threats-to-reliability">Threats to reliability</h2>
</section>
<section id="threats-to-internal-validity" class="level2">
<h2 class="anchored" data-anchor-id="threats-to-internal-validity">Threats to internal validity</h2>
<section id="misc-effects-some-of-them-relevant-only-for-field-experiments" class="level3">
<h3 class="anchored" data-anchor-id="misc-effects-some-of-them-relevant-only-for-field-experiments">Misc effects (some of them relevant only for field experiments)</h3>
<ul>
<li><p>Hawthorne effect: the treatment group works harder than normal.</p></li>
<li><p>John Henry effect: the comparison group competes with the treatment group.</p></li>
<li><p>Resentment and demoralising effect: not getting the treatment changes behaviour negatively.</p></li>
<li><p>Demand effect: treatment units more likely to do what they think is wanted from them.</p></li>
<li><p>Anticipation effect: control group changes behaviour in anticipation of future treatment.</p></li>
<li><p>Survey effect: being surveyed changes behaviour.</p></li>
</ul>
</section>
<section id="interference" class="level3">
<h3 class="anchored" data-anchor-id="interference">Interference</h3>
<ul>
<li><p>Basically, all violations to SUTVA</p></li>
<li><p>Interference can happen due to</p>
<ul>
<li><p>Network effects</p></li>
<li><p>Cannibalisation of resources in marketplaces</p></li>
<li><p>Shared resources (i.e.&nbsp;treatment slowing down site for everyone)</p></li>
</ul></li>
</ul>
</section>
<section id="interaction-effects" class="level3">
<h3 class="anchored" data-anchor-id="interaction-effects">Interaction effects</h3>
<ul>
<li><p>Users can be simultaneously part of multiple experiments, so that what we measure for reach of them is really the effect of the interaction of all of them. This means that, if only some features are implemented, the results after roll out could be different from those observed during the experiment period.</p></li>
<li><p>However, with large sample sizes, this should not generally be a problem because effects of different experiments average out between treatment and control group.</p></li>
<li><p>While the above may be true statistically, interaction effects can still lead to extremely poor user experiences (blue background interacted with blue font), which is why mature platforms aim to avoid them.</p></li>
</ul>
</section>
<section id="non-representative-users" class="level3">
<h3 class="anchored" data-anchor-id="non-representative-users">Non-representative users</h3>
<p>Possible scenarios:</p>
<ul>
<li><p>Our marketing department launches an add campaign and attracts a lot of unusual users to the site temporarily.</p></li>
<li><p>A competitor does the same and temporarily takes a ways users from our site.</p></li>
<li><p>Heavy-user bias: heavy users are more likely to be bucketed in an experiment, biasing the results relative to the overall effect of a feature. Depending on the context, this can be an issue.</p></li>
<li><p>Solution: run experiments for longer (thought this comes with opportunity costs, and will increase cookie churn)</p></li>
</ul>
</section>
<section id="survivor-bias" class="level3">
<h3 class="anchored" data-anchor-id="survivor-bias">Survivor bias</h3>
<ul>
<li>This is really just a version of the above: if you select only users that have used the product for some time, your sample is not representative of all users. The classic demonstration of survivor bias is <a href="https://en.wikipedia.org/wiki/Abraham_Wald">Abraham Wald’s</a> insight in WWII that you want to put extra armour where returning plans got hit the least, since it’s presumable the planes that got hit there that didn’t make it back.</li>
</ul>
<!-- ![Where would you put extra armour? By Martin Grandjean (vector), McGeddon (picture), Cameron Moll (concept) - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=102017718](../inputs/survivorship-bias.svg){width=50%} -->
</section>
<section id="novelty-and-learning-effects" class="level3">
<h3 class="anchored" data-anchor-id="novelty-and-learning-effects">Novelty and learning effects</h3>
<ul>
<li><p>Challenge: behaviour might change abruptly and temporarily in response to a new feature (novelty or “burn in” effect) or it might take a while for behaviour fully adapt to a new feature (learning effects). In both cases, the results from a relatively short experiment will not provide a representative picture of the long-run effects of a feature.</p></li>
<li><p>Examples: Increasing number of adds shows on Google led to increase in add revenue initially but then decrease of clicks in the long term because it increased add blindness <span class="citation" data-cites="hohnhold2015focusing">@hohnhold2015focusing</span></p></li>
<li><p>Solutions:</p>
<ul>
<li><p>Measure long-term effects (by running experiments for longer)</p></li>
<li><p>Have a “holdout” group of users that isn’t exposed to any changes for a pre-set period of time (a month, a quarter), to measure long-term effects</p></li>
<li><p>Estimate dynamic treatment effects to see the evolution of the treatment effect</p></li>
</ul></li>
</ul>
</section>
<section id="sample-ratio-mismatch" class="level3">
<h3 class="anchored" data-anchor-id="sample-ratio-mismatch">Sample ratio mismatch</h3>
</section>
</section>
<section id="treats-to-external-validity" class="level2">
<h2 class="anchored" data-anchor-id="treats-to-external-validity">Treats to external validity</h2>
<section id="budget-effects-in-ads" class="level3">
<h3 class="anchored" data-anchor-id="budget-effects-in-ads">Budget effects in Ads</h3>
<ul>
<li>On an adds platform, a treatment might perform very well during an experiment in that it makes marketers launch more adds. But once scaled up may do less well because the increased traffic might exhaust marketer’s budgets, leading them to reduce adds launched.</li>
</ul>
</section>
<section id="feedback-loops-from-personalisation" class="level3">
<h3 class="anchored" data-anchor-id="feedback-loops-from-personalisation">Feedback loops from personalisation</h3>
<ul>
<li>Treatments might behave differently during experimentation and once they are scaled up if the performance of a feature is a function of the size of the audience it is exposed to (an example could be a recommendation algorithm, which performs better and better as it is being used more).</li>
</ul>
</section>
<section id="day-of-week-effects" class="level3">
<h3 class="anchored" data-anchor-id="day-of-week-effects">Day-of-week effects</h3>
<ul>
<li>See below</li>
</ul>
</section>
<section id="seasonality" class="level3">
<h3 class="anchored" data-anchor-id="seasonality">Seasonality</h3>
<ul>
<li><p>Seasonality comes in many forms: day of week effects, week of year effects, season effects, holiday effects, etc.</p></li>
<li><p>The challenge is that, potentially, user behaviour might differ on certain days or over certain time periods either because we get different users or because users change their behaviour.</p></li>
<li><p>Whether it is really a problem depends on the context. One aspect that is often forgotten here is that seasonality, first and foremost, is about a shift in levels – activity on LinkedIn might go down during the summer months. What we usually want to measure, however, is the difference between treatment and control units. Hence, if you don’t have reason to believe that the effect of the treatment is different during a particular season (e.g.&nbsp;because you think it’s additive), then seasonality might not be a problem for you.</p></li>
<li><p>Having said that, it’s actually quite likely that with either different users or different behaviour by the same users, users might react differently to featore on different days. So it really is a thread to external validity, and we thus should usually care about it.</p></li>
<li><p>Solution: design your experiment so as to take seasonality into account. E.g. run your experiment for at least one week to account for day of week effects (that’s generally a good idea), don’t run crucial experiments during the holiday season or on major holidays or discard data from such periods, etc.</p></li>
<li><p>What to take into account depends on your context. So understand the relevant seasonality for you (if you’re a travel app, consider seasonality of travel demand, if you’re an e-commerce site, consider seasonality of shopping behaviour)</p></li>
</ul>
</section>
</section>
<section id="differences-in-time-to-action-between-users" class="level2">
<h2 class="anchored" data-anchor-id="differences-in-time-to-action-between-users">Differences in time-to-action between users</h2>
<ul>
<li><p>Some users may engage with a new features immediately, others might take a while and then react differently to it.</p></li>
<li><p>When running experiments for a very short time, we might thus get a biased picture of the overall effect of the feature.</p></li>
</ul>
</section>
<section id="integrate-from-social-science-literature" class="level2">
<h2 class="anchored" data-anchor-id="integrate-from-social-science-literature">Integrate: from social science literature</h2>
</section>
<section id="imperfect-compliance" class="level2">
<h2 class="anchored" data-anchor-id="imperfect-compliance">Imperfect compliance</h2>
<p>Partial complience</p>
<ul>
<li><p>Partial compliance occurs if, for some reason, some people in the treatment group are not treated or some people in the control group are.</p></li>
<li><p>It’s problematic because it reduces the difference in treatment exposure between treatment and control group (in the extreme, if they are equal, we learn nothing), and because they might make treatment takeup non-random.</p></li>
<li><p>A few things can help to limit the problem: make takeup easy and/or incentivise it, randomise at a higher level, and provide a treatment to everyone.</p></li>
<li><p>We can adjust our analysis by calculating LATE, either using the Wald estimator (ITT / difference in take-up between treatment and control groups) or 2SLS where we instrument the behaviour we want to encourage with the treatment dummy (and possibly other covariates).</p></li>
<li><p>Do not drop non-compliers or re-assign them to the control group – compliers and non-compliers are different so that dropping or reclassifying non-compliers would re-introduce self-selection into out two samples, which defeats the whole point of the randomisation.</p></li>
</ul>
<p>Defiers</p>
<ul>
<li><p>They are the opposite of compliers: they either take up the treatment because they were assigned to control or the other way around.</p></li>
<li><p>They might occur in an encouragement design if they overestimated the benefit of treatment and got discouraged by the information provided in the treatment.</p></li>
<li><p>They might make us significantly misinterpret the true effect (RRE page 303, or, better, MHE p 156).</p></li>
<li><p>We can deal with them only if they form an identifiable subgroup, in which case we can estimate the treatment effect on defiers and compliers separately and calculate an average treatment effect.</p></li>
</ul>
<p>In an experiment with one-sided non-compliance what does IV estimate 1. if there are no always-takers and 2. if there are not never-takers?</p>
<ul>
<li><p>In general, IV estimates LATE, the effect on compliers, and the treated consist of compliers and always-takers, while the non-treated consist of compliers and never-takers.</p></li>
<li><p>If there are no always-takers, the population of compliers is the same as the population of the treated, so that LATE = ATET.</p></li>
<li><p>If there are no never-takers, the population of compliers is the same as that of the untreated, so LATE = average treatment effect of the untreated.</p></li>
</ul>
</section>
<section id="attrition" class="level2">
<h2 class="anchored" data-anchor-id="attrition">Attrition</h2>
<p>Attrition is when, for some reason, we cannot collect endline data on some units.</p>
<p>It’s a problem because when it’s systematic rather than random, treatment and control group are no longer comparable, which is a threat to internal validity. (Even if the same number of people drop out, if they are different type, the problem is the same.) Also, it reduces sample size and thus power.</p>
<p>We can limit it if we promise access to the program to everyone (phase-in design), change the level of randomisation, and improve data collection.</p>
<p>In our analysis we should 1. Report the extent of attrition, 2. Check for differential attrition (between groups, and within groups based on observable characteristics), and 3. Determine the range of estimates given attrition using a selection model or bounds.</p>
<p>One method is to use Heckman’s selection model: we look at the characteristics of those who attrite, assume that they have the same outcomes as those with the same characteristics for which we have data, and then fill in their outcome variables accordingly.</p>
<p>Another method is to use bounds. There are two types.</p>
<p>Manski-Horowitz bounds: Lower bound: replace all missing values in treatment with the least favourable outcome value from the observed sample and replace all missing values in control with most favourable value in the observed sample. Upper bound created in a reverse way. Unless attrition is low and the outcome variable is tightly bounded, this tends to lead to very large bounds.</p>
<p>Lee bounds: We treat the estimate from the available data as an upper bound, and construct the lower bound by trimming from the sample with less attrition the observations that most contribute to the treatment effect.</p>
</section>
<section id="resources" class="level2">
<h2 class="anchored" data-anchor-id="resources">Resources</h2>
<ul>
<li><p><a href="https://www.forbes.com/sites/quora/2015/06/19/when-should-ab-testing-not-be-trusted-to-make-decisions/">Forbes article on when not to trust your A/B tests</a></p></li>
<li><p><a href="https://towardsdatascience.com/ab-testing-when-external-validity-messes-with-your-results-888197b6bc7b">Dennis Meisner discussing threats to external validity</a></p></li>
</ul>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>